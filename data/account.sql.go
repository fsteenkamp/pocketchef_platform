// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: account.sql

package data

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const accountCreate = `-- name: AccountCreate :exec
INSERT INTO account (
    id,
    email,
    is_admin,
    is_root,
    verified,
    password_hash,
    verify_code_hash,
    provider,
    provider_token,
    provider_refresh_token,
    provider_last_refresh,
    picture
)
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
`

type AccountCreateParams struct {
	ID                   string           `json:"id"`
	Email                string           `json:"email"`
	IsAdmin              bool             `json:"is_admin"`
	IsRoot               bool             `json:"is_root"`
	Verified             bool             `json:"verified"`
	PasswordHash         pgtype.Text      `json:"password_hash"`
	VerifyCodeHash       pgtype.Text      `json:"verify_code_hash"`
	Provider             pgtype.Text      `json:"provider"`
	ProviderToken        pgtype.Text      `json:"provider_token"`
	ProviderRefreshToken pgtype.Text      `json:"provider_refresh_token"`
	ProviderLastRefresh  pgtype.Timestamp `json:"provider_last_refresh"`
	Picture              pgtype.Text      `json:"picture"`
}

func (q *Queries) AccountCreate(ctx context.Context, arg AccountCreateParams) error {
	_, err := q.db.Exec(ctx, accountCreate,
		arg.ID,
		arg.Email,
		arg.IsAdmin,
		arg.IsRoot,
		arg.Verified,
		arg.PasswordHash,
		arg.VerifyCodeHash,
		arg.Provider,
		arg.ProviderToken,
		arg.ProviderRefreshToken,
		arg.ProviderLastRefresh,
		arg.Picture,
	)
	return err
}

const accountGetByEmail = `-- name: AccountGetByEmail :one
SELECT id, email, verified, verify_code_hash, profile_configured, phone_number, is_admin, is_root, created_at, updated_at, last_active, first_name, last_name, password_hash, provider, provider_token, provider_refresh_token, provider_last_refresh, picture, disabled, is_archived, archived_at, archived_by FROM account WHERE email = $1
`

func (q *Queries) AccountGetByEmail(ctx context.Context, email string) (Account, error) {
	row := q.db.QueryRow(ctx, accountGetByEmail, email)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Verified,
		&i.VerifyCodeHash,
		&i.ProfileConfigured,
		&i.PhoneNumber,
		&i.IsAdmin,
		&i.IsRoot,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastActive,
		&i.FirstName,
		&i.LastName,
		&i.PasswordHash,
		&i.Provider,
		&i.ProviderToken,
		&i.ProviderRefreshToken,
		&i.ProviderLastRefresh,
		&i.Picture,
		&i.Disabled,
		&i.IsArchived,
		&i.ArchivedAt,
		&i.ArchivedBy,
	)
	return i, err
}

const accountGetByID = `-- name: AccountGetByID :one
SELECT
    id,
    email,
    phone_number,
    is_admin,
    is_root,
    created_at,
    updated_at,
    last_active,
    first_name,
    last_name,
    provider,
    provider_last_refresh,
    picture,
    disabled,
    is_archived,
    archived_at,
    archived_by
FROM account WHERE id = $1
`

type AccountGetByIDRow struct {
	ID                  string           `json:"id"`
	Email               string           `json:"email"`
	PhoneNumber         pgtype.Text      `json:"phone_number"`
	IsAdmin             bool             `json:"is_admin"`
	IsRoot              bool             `json:"is_root"`
	CreatedAt           pgtype.Timestamp `json:"created_at"`
	UpdatedAt           pgtype.Timestamp `json:"updated_at"`
	LastActive          pgtype.Timestamp `json:"last_active"`
	FirstName           pgtype.Text      `json:"first_name"`
	LastName            pgtype.Text      `json:"last_name"`
	Provider            pgtype.Text      `json:"provider"`
	ProviderLastRefresh pgtype.Timestamp `json:"provider_last_refresh"`
	Picture             pgtype.Text      `json:"picture"`
	Disabled            bool             `json:"disabled"`
	IsArchived          bool             `json:"is_archived"`
	ArchivedAt          pgtype.Timestamp `json:"archived_at"`
	ArchivedBy          pgtype.Text      `json:"archived_by"`
}

func (q *Queries) AccountGetByID(ctx context.Context, id string) (AccountGetByIDRow, error) {
	row := q.db.QueryRow(ctx, accountGetByID, id)
	var i AccountGetByIDRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PhoneNumber,
		&i.IsAdmin,
		&i.IsRoot,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastActive,
		&i.FirstName,
		&i.LastName,
		&i.Provider,
		&i.ProviderLastRefresh,
		&i.Picture,
		&i.Disabled,
		&i.IsArchived,
		&i.ArchivedAt,
		&i.ArchivedBy,
	)
	return i, err
}

const accountInit = `-- name: AccountInit :one
SELECT
    id,
    email,
    phone_number,
    is_admin,
    is_root,
    created_at,
    updated_at,
    last_active,
    first_name,
    last_name,
    provider,
    provider_last_refresh,
    picture,
    disabled,
    is_archived,
    archived_at,
    archived_by
FROM account WHERE id = $1
`

type AccountInitRow struct {
	ID                  string           `json:"id"`
	Email               string           `json:"email"`
	PhoneNumber         pgtype.Text      `json:"phone_number"`
	IsAdmin             bool             `json:"is_admin"`
	IsRoot              bool             `json:"is_root"`
	CreatedAt           pgtype.Timestamp `json:"created_at"`
	UpdatedAt           pgtype.Timestamp `json:"updated_at"`
	LastActive          pgtype.Timestamp `json:"last_active"`
	FirstName           pgtype.Text      `json:"first_name"`
	LastName            pgtype.Text      `json:"last_name"`
	Provider            pgtype.Text      `json:"provider"`
	ProviderLastRefresh pgtype.Timestamp `json:"provider_last_refresh"`
	Picture             pgtype.Text      `json:"picture"`
	Disabled            bool             `json:"disabled"`
	IsArchived          bool             `json:"is_archived"`
	ArchivedAt          pgtype.Timestamp `json:"archived_at"`
	ArchivedBy          pgtype.Text      `json:"archived_by"`
}

func (q *Queries) AccountInit(ctx context.Context, id string) (AccountInitRow, error) {
	row := q.db.QueryRow(ctx, accountInit, id)
	var i AccountInitRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PhoneNumber,
		&i.IsAdmin,
		&i.IsRoot,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastActive,
		&i.FirstName,
		&i.LastName,
		&i.Provider,
		&i.ProviderLastRefresh,
		&i.Picture,
		&i.Disabled,
		&i.IsArchived,
		&i.ArchivedAt,
		&i.ArchivedBy,
	)
	return i, err
}

const accountList = `-- name: AccountList :many
SELECT
    id,
    email,
    phone_number,
    is_admin,
    is_root,
    created_at,
    updated_at,
    last_active,
    first_name,
    last_name,
    provider,
    provider_last_refresh,
    picture,
    disabled,
    is_archived,
    archived_at,
    archived_by
FROM
    account
`

type AccountListRow struct {
	ID                  string           `json:"id"`
	Email               string           `json:"email"`
	PhoneNumber         pgtype.Text      `json:"phone_number"`
	IsAdmin             bool             `json:"is_admin"`
	IsRoot              bool             `json:"is_root"`
	CreatedAt           pgtype.Timestamp `json:"created_at"`
	UpdatedAt           pgtype.Timestamp `json:"updated_at"`
	LastActive          pgtype.Timestamp `json:"last_active"`
	FirstName           pgtype.Text      `json:"first_name"`
	LastName            pgtype.Text      `json:"last_name"`
	Provider            pgtype.Text      `json:"provider"`
	ProviderLastRefresh pgtype.Timestamp `json:"provider_last_refresh"`
	Picture             pgtype.Text      `json:"picture"`
	Disabled            bool             `json:"disabled"`
	IsArchived          bool             `json:"is_archived"`
	ArchivedAt          pgtype.Timestamp `json:"archived_at"`
	ArchivedBy          pgtype.Text      `json:"archived_by"`
}

func (q *Queries) AccountList(ctx context.Context) ([]AccountListRow, error) {
	rows, err := q.db.Query(ctx, accountList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AccountListRow
	for rows.Next() {
		var i AccountListRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.PhoneNumber,
			&i.IsAdmin,
			&i.IsRoot,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastActive,
			&i.FirstName,
			&i.LastName,
			&i.Provider,
			&i.ProviderLastRefresh,
			&i.Picture,
			&i.Disabled,
			&i.IsArchived,
			&i.ArchivedAt,
			&i.ArchivedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const accountRefreshProviderDetails = `-- name: AccountRefreshProviderDetails :exec
UPDATE account
SET
    first_name = $2,
    last_name = $3,
    phone_number = $4,
    picture = $5
WHERE
    id = $1
`

type AccountRefreshProviderDetailsParams struct {
	ID          string      `json:"id"`
	FirstName   pgtype.Text `json:"first_name"`
	LastName    pgtype.Text `json:"last_name"`
	PhoneNumber pgtype.Text `json:"phone_number"`
	Picture     pgtype.Text `json:"picture"`
}

func (q *Queries) AccountRefreshProviderDetails(ctx context.Context, arg AccountRefreshProviderDetailsParams) error {
	_, err := q.db.Exec(ctx, accountRefreshProviderDetails,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.PhoneNumber,
		arg.Picture,
	)
	return err
}

const accountSetLastActive = `-- name: AccountSetLastActive :exec
UPDATE account
SET
    last_active = $2
WHERE id = $1
`

type AccountSetLastActiveParams struct {
	ID         string           `json:"id"`
	LastActive pgtype.Timestamp `json:"last_active"`
}

func (q *Queries) AccountSetLastActive(ctx context.Context, arg AccountSetLastActiveParams) error {
	_, err := q.db.Exec(ctx, accountSetLastActive, arg.ID, arg.LastActive)
	return err
}

const accountSetVerified = `-- name: AccountSetVerified :exec
UPDATE account
SET verified = true
WHERE verify_code_hash = $1
`

func (q *Queries) AccountSetVerified(ctx context.Context, verifyCodeHash pgtype.Text) error {
	_, err := q.db.Exec(ctx, accountSetVerified, verifyCodeHash)
	return err
}
