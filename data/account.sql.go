// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: account.sql

package data

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const accountCreate = `-- name: AccountCreate :exec
INSERT INTO account (
    id,
    email,
    is_admin,
    is_root,
    verified,
    password_hash,
    verify_code_hash,
    provider,
    provider_token,
    provider_refresh_token,
    provider_last_refresh,
    picture
)
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
`

type AccountCreateParams struct {
	ID                   string           `json:"id"`
	Email                string           `json:"email"`
	IsAdmin              bool             `json:"is_admin"`
	IsRoot               bool             `json:"is_root"`
	Verified             bool             `json:"verified"`
	PasswordHash         pgtype.Text      `json:"password_hash"`
	VerifyCodeHash       pgtype.Text      `json:"verify_code_hash"`
	Provider             pgtype.Text      `json:"provider"`
	ProviderToken        pgtype.Text      `json:"provider_token"`
	ProviderRefreshToken pgtype.Text      `json:"provider_refresh_token"`
	ProviderLastRefresh  pgtype.Timestamp `json:"provider_last_refresh"`
	Picture              pgtype.Text      `json:"picture"`
}

func (q *Queries) AccountCreate(ctx context.Context, arg AccountCreateParams) error {
	_, err := q.db.Exec(ctx, accountCreate,
		arg.ID,
		arg.Email,
		arg.IsAdmin,
		arg.IsRoot,
		arg.Verified,
		arg.PasswordHash,
		arg.VerifyCodeHash,
		arg.Provider,
		arg.ProviderToken,
		arg.ProviderRefreshToken,
		arg.ProviderLastRefresh,
		arg.Picture,
	)
	return err
}

const accountGetByEmail = `-- name: AccountGetByEmail :one
SELECT id, email, verified, verify_code_hash, profile_configured, phone_number, is_admin, is_root, created_at, updated_at, last_active, first_name, last_name, password_hash, provider, provider_token, provider_refresh_token, provider_last_refresh, picture, disabled, is_archived, archived_at, archived_by FROM account WHERE email = $1
`

func (q *Queries) AccountGetByEmail(ctx context.Context, email string) (Account, error) {
	row := q.db.QueryRow(ctx, accountGetByEmail, email)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Verified,
		&i.VerifyCodeHash,
		&i.ProfileConfigured,
		&i.PhoneNumber,
		&i.IsAdmin,
		&i.IsRoot,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastActive,
		&i.FirstName,
		&i.LastName,
		&i.PasswordHash,
		&i.Provider,
		&i.ProviderToken,
		&i.ProviderRefreshToken,
		&i.ProviderLastRefresh,
		&i.Picture,
		&i.Disabled,
		&i.IsArchived,
		&i.ArchivedAt,
		&i.ArchivedBy,
	)
	return i, err
}

const accountGetByID = `-- name: AccountGetByID :one
SELECT
    id,
    email,
    phone_number,
    is_admin,
    is_root,
    created_at,
    updated_at,
    last_active,
    first_name,
    last_name,
    provider,
    provider_last_refresh,
    picture,
    disabled,
    is_archived,
    archived_at,
    archived_by
FROM account WHERE id = $1
`

type AccountGetByIDRow struct {
	ID                  string           `json:"id"`
	Email               string           `json:"email"`
	PhoneNumber         pgtype.Text      `json:"phone_number"`
	IsAdmin             bool             `json:"is_admin"`
	IsRoot              bool             `json:"is_root"`
	CreatedAt           pgtype.Timestamp `json:"created_at"`
	UpdatedAt           pgtype.Timestamp `json:"updated_at"`
	LastActive          pgtype.Timestamp `json:"last_active"`
	FirstName           pgtype.Text      `json:"first_name"`
	LastName            pgtype.Text      `json:"last_name"`
	Provider            pgtype.Text      `json:"provider"`
	ProviderLastRefresh pgtype.Timestamp `json:"provider_last_refresh"`
	Picture             pgtype.Text      `json:"picture"`
	Disabled            bool             `json:"disabled"`
	IsArchived          bool             `json:"is_archived"`
	ArchivedAt          pgtype.Timestamp `json:"archived_at"`
	ArchivedBy          pgtype.Text      `json:"archived_by"`
}

func (q *Queries) AccountGetByID(ctx context.Context, id string) (AccountGetByIDRow, error) {
	row := q.db.QueryRow(ctx, accountGetByID, id)
	var i AccountGetByIDRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PhoneNumber,
		&i.IsAdmin,
		&i.IsRoot,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastActive,
		&i.FirstName,
		&i.LastName,
		&i.Provider,
		&i.ProviderLastRefresh,
		&i.Picture,
		&i.Disabled,
		&i.IsArchived,
		&i.ArchivedAt,
		&i.ArchivedBy,
	)
	return i, err
}

const accountInit = `-- name: AccountInit :one
SELECT
    account.id                              id,
    account.email                           email,
    account.phone_number                    phone_number,
    account.is_admin                        is_admin,
    account.is_root                         is_root,
    account.created_at                      created_at,
    account.updated_at                      updated_at,
    account.last_active                     last_active,
    account.first_name                      first_name,
    account.last_name                       last_name,
    account.provider                        provider,
    account.provider_last_refresh           provider_last_refresh,
    account.picture                         picture,
    account.disabled                        disabled,
    account.is_archived                     is_archived,
    account.archived_at                     archived_at,
    account.archived_by                     archived_by,
    json_agg(json_build_object(
        'id',                               chef.id,
        'account_id',                       chef.account_id,
        'display_name',                     chef.display_name,
        'description',                      chef.description,
        'picture',                          chef.picture,
        'phone_number',                     chef.phone_number,
        'chef_status',                      chef.chef_status,
        'created_at',                       chef.created_at,
        'updated_at',                       chef.updated_at,
        'archived_at',                      chef.archived_at,
        'archived_by',                      chef.archived_by,
        'social_link_instagram',            chef.social_link_instagram,
        'social_link_facebook',             chef.social_link_facebook,
        'social_link_website',              chef.social_link_website,
        'social_link_x',                    chef.social_link_x,
        'social_link_tiktok',               chef.social_link_tiktok,
        'social_link_youtube',              chef.social_link_youtube
    )) FILTER (WHERE chef.id IS NOT NULL)   chef_profile
FROM account
LEFT JOIN chef
ON
    chef.account_id = account.id
WHERE account.id = $1
GROUP BY account.id
`

type AccountInitRow struct {
	ID                  string           `json:"id"`
	Email               string           `json:"email"`
	PhoneNumber         pgtype.Text      `json:"phone_number"`
	IsAdmin             bool             `json:"is_admin"`
	IsRoot              bool             `json:"is_root"`
	CreatedAt           pgtype.Timestamp `json:"created_at"`
	UpdatedAt           pgtype.Timestamp `json:"updated_at"`
	LastActive          pgtype.Timestamp `json:"last_active"`
	FirstName           pgtype.Text      `json:"first_name"`
	LastName            pgtype.Text      `json:"last_name"`
	Provider            pgtype.Text      `json:"provider"`
	ProviderLastRefresh pgtype.Timestamp `json:"provider_last_refresh"`
	Picture             pgtype.Text      `json:"picture"`
	Disabled            bool             `json:"disabled"`
	IsArchived          bool             `json:"is_archived"`
	ArchivedAt          pgtype.Timestamp `json:"archived_at"`
	ArchivedBy          pgtype.Text      `json:"archived_by"`
	ChefProfile         []byte           `json:"chef_profile"`
}

func (q *Queries) AccountInit(ctx context.Context, id string) (AccountInitRow, error) {
	row := q.db.QueryRow(ctx, accountInit, id)
	var i AccountInitRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PhoneNumber,
		&i.IsAdmin,
		&i.IsRoot,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastActive,
		&i.FirstName,
		&i.LastName,
		&i.Provider,
		&i.ProviderLastRefresh,
		&i.Picture,
		&i.Disabled,
		&i.IsArchived,
		&i.ArchivedAt,
		&i.ArchivedBy,
		&i.ChefProfile,
	)
	return i, err
}

const accountList = `-- name: AccountList :many
SELECT
    id,
    email,
    phone_number,
    is_admin,
    is_root,
    created_at,
    updated_at,
    last_active,
    first_name,
    last_name,
    provider,
    provider_last_refresh,
    picture,
    disabled,
    is_archived,
    archived_at,
    archived_by
FROM
    account
`

type AccountListRow struct {
	ID                  string           `json:"id"`
	Email               string           `json:"email"`
	PhoneNumber         pgtype.Text      `json:"phone_number"`
	IsAdmin             bool             `json:"is_admin"`
	IsRoot              bool             `json:"is_root"`
	CreatedAt           pgtype.Timestamp `json:"created_at"`
	UpdatedAt           pgtype.Timestamp `json:"updated_at"`
	LastActive          pgtype.Timestamp `json:"last_active"`
	FirstName           pgtype.Text      `json:"first_name"`
	LastName            pgtype.Text      `json:"last_name"`
	Provider            pgtype.Text      `json:"provider"`
	ProviderLastRefresh pgtype.Timestamp `json:"provider_last_refresh"`
	Picture             pgtype.Text      `json:"picture"`
	Disabled            bool             `json:"disabled"`
	IsArchived          bool             `json:"is_archived"`
	ArchivedAt          pgtype.Timestamp `json:"archived_at"`
	ArchivedBy          pgtype.Text      `json:"archived_by"`
}

func (q *Queries) AccountList(ctx context.Context) ([]AccountListRow, error) {
	rows, err := q.db.Query(ctx, accountList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AccountListRow
	for rows.Next() {
		var i AccountListRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.PhoneNumber,
			&i.IsAdmin,
			&i.IsRoot,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastActive,
			&i.FirstName,
			&i.LastName,
			&i.Provider,
			&i.ProviderLastRefresh,
			&i.Picture,
			&i.Disabled,
			&i.IsArchived,
			&i.ArchivedAt,
			&i.ArchivedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const accountRefreshProviderDetails = `-- name: AccountRefreshProviderDetails :exec
UPDATE account
SET
    first_name = $2,
    last_name = $3,
    phone_number = $4,
    picture = $5
WHERE
    id = $1
`

type AccountRefreshProviderDetailsParams struct {
	ID          string      `json:"id"`
	FirstName   pgtype.Text `json:"first_name"`
	LastName    pgtype.Text `json:"last_name"`
	PhoneNumber pgtype.Text `json:"phone_number"`
	Picture     pgtype.Text `json:"picture"`
}

func (q *Queries) AccountRefreshProviderDetails(ctx context.Context, arg AccountRefreshProviderDetailsParams) error {
	_, err := q.db.Exec(ctx, accountRefreshProviderDetails,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.PhoneNumber,
		arg.Picture,
	)
	return err
}

const accountSetAdmin = `-- name: AccountSetAdmin :exec
UPDATE account
SET
    is_admin = $2
WHERE
    id = $1
`

type AccountSetAdminParams struct {
	ID      string `json:"id"`
	IsAdmin bool   `json:"is_admin"`
}

func (q *Queries) AccountSetAdmin(ctx context.Context, arg AccountSetAdminParams) error {
	_, err := q.db.Exec(ctx, accountSetAdmin, arg.ID, arg.IsAdmin)
	return err
}

const accountSetLastActive = `-- name: AccountSetLastActive :exec
UPDATE account
SET
    last_active = $2
WHERE id = $1
`

type AccountSetLastActiveParams struct {
	ID         string           `json:"id"`
	LastActive pgtype.Timestamp `json:"last_active"`
}

func (q *Queries) AccountSetLastActive(ctx context.Context, arg AccountSetLastActiveParams) error {
	_, err := q.db.Exec(ctx, accountSetLastActive, arg.ID, arg.LastActive)
	return err
}

const accountSetRoot = `-- name: AccountSetRoot :exec
UPDATE account
SET
    is_root  =  $2,
    is_admin =  $2
WHERE
    id = $1
`

type AccountSetRootParams struct {
	ID     string `json:"id"`
	IsRoot bool   `json:"is_root"`
}

func (q *Queries) AccountSetRoot(ctx context.Context, arg AccountSetRootParams) error {
	_, err := q.db.Exec(ctx, accountSetRoot, arg.ID, arg.IsRoot)
	return err
}

const accountSetVerified = `-- name: AccountSetVerified :exec
UPDATE account
SET verified = true
WHERE verify_code_hash = $1
`

func (q *Queries) AccountSetVerified(ctx context.Context, verifyCodeHash pgtype.Text) error {
	_, err := q.db.Exec(ctx, accountSetVerified, verifyCodeHash)
	return err
}
